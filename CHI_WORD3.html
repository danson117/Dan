<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flashcard & Spelling Pro (Ultimate)</title>
<style>
:root { --primary: #4f46e5; --secondary: #10b981; --bg: #f3f4f6; --card-bg: #ffffff; --text: #1f2937; --accent: #f59e0b; }
* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
/* Layout */
header { background: var(--card-bg); padding: 10px 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); display: flex; justify-content: space-between; align-items: center; z-index: 10; }
h1 { margin: 0; font-size: 1.2rem; color: var(--primary); display: flex; align-items: center; gap: 5px; }
.mode-switch { display: flex; background: #e5e7eb; border-radius: 20px; padding: 2px; }
.mode-btn { border: none; background: none; padding: 5px 12px; border-radius: 18px; font-size: 0.85rem; cursor: pointer; transition: 0.3s; color: #6b7280; }
.mode-btn.active { background: var(--primary); color: white; shadow: 0 2px 5px rgba(0,0,0,0.1); }
main { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; align-items: center; }
/* Cards & Containers */
.card-container { background: var(--card-bg); border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); width: 100%; max-width: 500px; padding: 20px; margin-bottom: 20px; transition: transform 0.2s; }
.setup-box { width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 15px; }
textarea { width: 100%; height: 120px; padding: 12px; border: 2px solid #e5e7eb; border-radius: 12px; font-size: 1rem; resize: vertical; transition: border 0.3s; }
textarea:focus { border-color: var(--primary); outline: none; }
/* Buttons */
.btn { border: none; padding: 12px 20px; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 8px; width: 100%; }
.btn:active { transform: scale(0.98); }
.btn-primary { background: var(--primary); color: white; }
.btn-secondary { background: var(--secondary); color: white; }
.btn-accent { background: var(--accent); color: white; }
.btn-outline { background: transparent; border: 2px solid #e5e7eb; color: #6b7280; }
.btn-group { display: flex; gap: 10px; }
.btn-sm { padding: 6px 12px; font-size: 0.85rem; width: auto; }
/* Flashcard Specific */
.flashcard { height: 250px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; cursor: pointer; position: relative; perspective: 1000px; }
.word-display { font-size: 2.5rem; font-weight: 700; color: var(--text); margin-bottom: 10px; }
.phonetic { font-size: 1.2rem; color: #6b7280; }
.card-actions { display: flex; justify-content: space-between; margin-top: 20px; gap: 10px; }
/* Spelling Pro Specific */
.spelling-area { text-align: center; }
.spelling-input { font-size: 1.5rem; text-align: center; border: none; border-bottom: 3px solid var(--primary); background: transparent; width: 80%; padding: 10px; margin: 20px 0; outline: none; }
.spelling-feedback { height: 30px; font-weight: bold; margin-bottom: 10px; }
.correct { color: var(--secondary); } .wrong { color: #ef4444; }
/* Settings & Toggles */
.settings-panel { background: #f9fafb; padding: 15px; border-radius: 12px; font-size: 0.9rem; }
.setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.setting-row:last-child { margin-bottom: 0; }
input[type="range"] { width: 100px; }
/* Dictation Specific Styles */
.dictation-tools { display: flex; gap: 8px; margin-bottom: 5px; }
.checkbox-wrapper { display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: 500; color: var(--primary); background: #e0e7ff; padding: 8px 12px; border-radius: 8px; width: fit-content; }
.checkbox-wrapper input { width: 18px; height: 18px; cursor: pointer; }
/* Modal */
.modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(3px); }
.modal-content { background: white; padding: 25px; border-radius: 16px; width: 90%; max-width: 400px; max-height: 80vh; overflow-y: auto; }
/* Confetti */
canvas#confetti { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; }
</style>
</head>
<body>

<header>
    <h1>ğŸ“š è­˜å­—å¯¶</h1>
    <div class="mode-switch">
        <button class="mode-btn active" onclick="switchMode('flashcard')">èªå­—å¡</button>
        <button class="mode-btn" onclick="switchMode('spelling')">é»˜æ›¸</button>
    </div>
    <button class="btn-sm btn-outline" onclick="openSettings()">âš™ï¸</button>
</header>

<main id="app-container">
    <!-- é€™è£¡çš„å…§å®¹æœƒç”± JS å‹•æ…‹ç”Ÿæˆ -->
</main>

<!-- Settings Modal -->
<div id="settings-modal" class="modal" onclick="if(event.target===this) closeSettings()">
    <div class="modal-content">
        <h2>âš™ï¸ è¨­å®š</h2>
        <div class="setting-row">
            <label>å»£æ±è©±è²éŸ³</label>
            <select id="voice-zh" onchange="saveSettings()"></select>
        </div>
        <div class="setting-row">
            <label>è‹±æ–‡è²éŸ³</label>
            <select id="voice-en" onchange="saveSettings()"></select>
        </div>
        <div class="setting-row">
            <label>èªé€Ÿ (Speed)</label>
            <input type="range" id="voice-rate" min="0.5" max="1.5" step="0.1" value="0.8" oninput="document.getElementById('rate-val').innerText=this.value; saveSettings()">
            <span id="rate-val">0.8</span>
        </div>
        <hr style="border:0; border-top:1px solid #eee; margin:15px 0;">
        <div class="setting-row">
            <label>è‡ªå‹•æ’­æ”¾ (èªå­—å¡)</label>
            <input type="checkbox" id="auto-play" onchange="saveSettings()">
        </div>
        <div class="setting-row">
            <label>è®€ä¸‰æ¬¡ (é»˜æ›¸)</label>
            <input type="checkbox" id="repeat-thrice" onchange="saveSettings()">
        </div>
        <button class="btn btn-primary" style="margin-top:20px" onclick="closeSettings()">å®Œæˆ</button>
    </div>
</div>

<canvas id="confetti"></canvas>

<script>
// --- Data & State ---
let db;
let currentMode = 'flashcard'; // 'flashcard' or 'spelling'
let words = []; // Current list of words/sentences
let currentIndex = 0;
let settings = { voiceZh: '', voiceEn: '', rate: 0.8, autoPlay: false, repeatThrice: false, readPunctuation: true };
let synth = window.speechSynthesis;
let voices = [];

// --- Initialization ---
window.onload = async () => {
    await initDB();
    loadSettings();
    populateVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = populateVoices;
    render();
};

// --- IndexedDB ---
function initDB() {
    return new Promise((resolve) => {
        const request = indexedDB.open("FlashcardDB", 1);
        request.onupgradeneeded = e => {
            let db = e.target.result;
            if (!db.objectStoreNames.contains('history')) db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
        };
        request.onsuccess = e => { db = e.target.result; resolve(); };
        request.onerror = () => resolve();
    });
}

// --- Settings & Voices ---
function populateVoices() {
    voices = synth.getVoices();
    const zhSelect = document.getElementById('voice-zh');
    const enSelect = document.getElementById('voice-en');
    zhSelect.innerHTML = enSelect.innerHTML = '';
    
    voices.forEach(v => {
        const opt = new Option(`${v.name} (${v.lang})`, v.name);
        if (v.lang.includes('zh') || v.lang.includes('HK') || v.lang.includes('CN')) zhSelect.add(opt.cloneNode(true));
        if (v.lang.includes('en')) enSelect.add(opt.cloneNode(true));
    });
    
    // Auto-select best voices if not set
    if (!settings.voiceZh) selectBestVoice(zhSelect, ['HiuGaai', 'WanLung', 'Hong Kong', 'Chinese']);
    if (!settings.voiceEn) selectBestVoice(enSelect, ['Natural', 'Google US', 'English']);
}

function selectBestVoice(select, keywords) {
    for (let k of keywords) {
        for (let i=0; i<select.options.length; i++) {
            if (select.options[i].text.includes(k)) { select.selectedIndex = i; settings[select.id === 'voice-zh' ? 'voiceZh' : 'voiceEn'] = select.value; return; }
        }
    }
}

function loadSettings() {
    const s = localStorage.getItem('fc_settings');
    if (s) settings = {...settings, ...JSON.parse(s)};
    document.getElementById('voice-rate').value = settings.rate;
    document.getElementById('rate-val').innerText = settings.rate;
    document.getElementById('auto-play').checked = settings.autoPlay;
    document.getElementById('repeat-thrice').checked = settings.repeatThrice;
}

function saveSettings() {
    settings.voiceZh = document.getElementById('voice-zh').value;
    settings.voiceEn = document.getElementById('voice-en').value;
    settings.rate = parseFloat(document.getElementById('voice-rate').value);
    settings.autoPlay = document.getElementById('auto-play').checked;
    settings.repeatThrice = document.getElementById('repeat-thrice').checked;
    localStorage.setItem('fc_settings', JSON.stringify(settings));
}

function openSettings() { document.getElementById('settings-modal').style.display = 'flex'; }
function closeSettings() { document.getElementById('settings-modal').style.display = 'none'; }

// --- Core Logic ---
function switchMode(mode) {
    currentMode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.querySelector(`.mode-btn[onclick="switchMode('${mode}')"]`).classList.add('active');
    render();
}

function parseInput(text) {
    // Split by newlines, filter empty
    return text.split(/\n/).map(w => w.trim()).filter(w => w.length > 0);
}

// --- Rendering ---
function render() {
    const container = document.getElementById('app-container');
    container.innerHTML = '';

    if (words.length === 0) {
        renderSetup(container);
    } else {
        if (currentMode === 'flashcard') renderFlashcard(container);
        else renderSpelling(container);
    }
}

function renderSetup(container) {
    const isSpelling = currentMode === 'spelling';
    
    let html = `
        <div class="setup-box fade-in">
            <div style="text-align:center; margin-bottom:10px;">
                <h2>${isSpelling ? 'ğŸ“ é»˜æ›¸æº–å‚™' : 'ğŸ“‡ èªå­—å¡æº–å‚™'}</h2>
                <p style="color:#6b7280; font-size:0.9rem;">è¼¸å…¥æ–‡å­—ï¼Œæ¯è¡Œä¸€å¥/ä¸€å€‹è©</p>
            </div>
    `;

    // é»˜æ›¸æ¨¡å¼å°ˆç”¨ï¼šä¾‹å¥æŒ‰éˆ•å’Œæ¨™é»é–‹é—œ
    if (isSpelling) {
        html += `
            <div class="dictation-tools">
                <button class="btn btn-sm btn-outline" onclick="insertSample('zh')">ğŸ“ ä¸­æ–‡ä¾‹å¥</button>
                <button class="btn btn-sm btn-outline" onclick="insertSample('en')">ğŸ“ English Ex.</button>
            </div>
            <textarea id="input-words" placeholder="åœ¨æ­¤è¼¸å…¥è¦é»˜æ›¸çš„å…§å®¹..."></textarea>
            <label class="checkbox-wrapper">
                <input type="checkbox" id="punct-check" ${settings.readPunctuation ? 'checked' : ''} onchange="settings.readPunctuation = this.checked; saveSettings()">
                <span>ğŸ—£ï¸ è®€å‡ºæ¨™é»ç¬¦è™Ÿ (ï¼Œ= é€—è™Ÿ)</span>
            </label>
        `;
    } else {
        html += `<textarea id="input-words" placeholder="è¼¸å…¥å–®å­—ï¼Œä¾‹å¦‚ï¼š\nè˜‹æœ\nApple\né¦™è•‰"></textarea>`;
    }

    html += `
            <div class="btn-group">
                <button class="btn btn-primary" onclick="startApp()">â–¶ï¸ é–‹å§‹${isSpelling ? 'é»˜æ›¸' : 'ç·´ç¿’'}</button>
                <button class="btn btn-outline" onclick="triggerCamera()">ğŸ“· å½±ç›¸å°å…¥</button>
            </div>
            <input type="file" id="cam-input" accept="image/*" capture="environment" style="display:none" onchange="handleOCR(this)">
            <div id="ocr-loading" style="display:none; text-align:center; color:var(--primary);">æ­£åœ¨è®€å–æ–‡å­—... âŒ›</div>
        </div>
    `;
    container.innerHTML = html;
}

function insertSample(lang) {
    const ta = document.getElementById('input-words');
    if (lang === 'zh') {
        ta.value = "è«‹æ³¨æ„ï¼šæ˜å¤©çš„æœƒè­°å°‡å»¶é²èˆ‰è¡Œï¼›å› æ­¤ï¼Œè«‹å¤§å®¶å‹™å¿…é‡æ–°ç¢ºèªæ™‚é–“è¡¨ã€‚";
    } else {
        ta.value = "Please note: the meeting tomorrow will be delayed; therefore, please check your schedule again.";
    }
}

function startApp() {
    const text = document.getElementById('input-words').value;
    if (!text.trim()) return alert("è«‹è¼¸å…¥æ–‡å­—ï¼");
    words = parseInput(text);
    currentIndex = 0;
    render();
}

// --- Flashcard Mode ---
function renderFlashcard(container) {
    const word = words[currentIndex];
    container.innerHTML = `
        <div class="card-container">
            <div class="flashcard" onclick="speak('${word.replace(/'/g, "\\'")}')">
                <div class="word-display">${word}</div>
                <div class="phonetic">ğŸ‘† é»æ“Šç™¼éŸ³</div>
            </div>
            <div class="card-actions">
                <button class="btn btn-outline" onclick="prevCard()">â®ï¸</button>
                <button class="btn btn-secondary" onclick="markKnown()">âœ… è­˜</button>
                <button class="btn btn-accent" onclick="markUnknown()">âŒ å””è­˜</button>
                <button class="btn btn-outline" onclick="nextCard()">â­ï¸</button>
            </div>
            <button class="btn btn-outline" style="margin-top:10px" onclick="exitApp()">â¹ï¸ çµæŸç·´ç¿’</button>
        </div>
    `;
    if (settings.autoPlay) setTimeout(() => speak(word), 500);
}

// --- Spelling Mode (Dictation) ---
function renderSpelling(container) {
    const word = words[currentIndex];
    container.innerHTML = `
        <div class="card-container spelling-area">
            <div style="font-size:0.9rem; color:#6b7280; margin-bottom:10px;">ç¬¬ ${currentIndex + 1} / ${words.length} å¥</div>
            <button class="btn btn-primary" onclick="speakCurrentSpelling()">ğŸ”Š è®€é¡Œç›®</button>
            
            <input type="text" class="spelling-input" id="spell-in" placeholder="åœ¨æ­¤è¼¸å…¥..." autocomplete="off">
            <div id="feedback" class="spelling-feedback"></div>
            
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="checkSpelling()">âœ… æª¢æŸ¥</button>
                <button class="btn btn-accent" onclick="showAnswer()">ğŸ‘€ å·ç‡</button>
            </div>
            <button class="btn btn-outline" style="margin-top:15px" onclick="nextCard()">â­ï¸ ä¸‹ä¸€å¥</button>
            <button class="btn btn-outline" style="margin-top:10px" onclick="exitApp()">â¹ï¸ çµæŸ</button>
        </div>
    `;
    // Auto speak first time
    setTimeout(() => speakCurrentSpelling(), 500);
}

function speakCurrentSpelling() {
    let text = words[currentIndex];
    // å¦‚æœé–‹å•Ÿäº†æ¨™é»æœ—è®€ï¼Œé€²è¡Œè½‰æ›
    if (settings.readPunctuation) {
        text = processTextForDictation(text);
    }
    
    // é»˜æ›¸æ¨¡å¼é‚è¼¯ï¼šå¯èƒ½è®€ä¸‰æ¬¡
    if (settings.repeatThrice) {
        speak(text, () => setTimeout(() => speak(text, () => setTimeout(() => speak(text), 1000)), 1000));
    } else {
        speak(text);
    }
}

// æ¨™é»ç¬¦è™Ÿè½‰æ›é‚è¼¯ (æ ¸å¿ƒåŠŸèƒ½)
function processTextForDictation(text) {
    // ç°¡å–®åˆ¤æ–·ä¸»è¦èªè¨€
    const isZh = /[\u4e00-\u9fa5]/.test(text);
    
    if (isZh) {
        return text.replace(/ï¼Œ/g, "ï¼Œé€—è™Ÿï¼Œ")
                   .replace(/ã€‚/g, "ï¼Œå¥è™Ÿã€‚")
                   .replace(/ï¼›/g, "ï¼Œåˆ†è™Ÿï¼Œ")
                   .replace(/ï¼š/g, "ï¼Œå†’è™Ÿï¼Œ")
                   .replace(/ï¼Ÿ/g, "ï¼Œå•è™Ÿï¼Œ")
                   .replace(/ï¼/g, "ï¼Œé©šå˜†è™Ÿï¼Œ")
                   .replace(/,/g, "ï¼Œé€—è™Ÿï¼Œ")
                   .replace(/\./g, "ï¼Œå¥è™Ÿã€‚");
    } else {
        return text.replace(/,/g, ", comma, ")
                   .replace(/\./g, ", full stop. ")
                   .replace(/;/g, ", semicolon, ")
                   .replace(/:/g, ", colon, ")
                   .replace(/\?/g, ", question mark, ")
                   .replace(/!/g, ", exclamation mark, ");
    }
}

function checkSpelling() {
    const input = document.getElementById('spell-in').value.trim();
    const target = words[currentIndex].trim();
    const fb = document.getElementById('feedback');
    
    // ç§»é™¤æ¨™é»é€²è¡Œæ¯”è¼ƒ (å¯¬å®¹æ¨¡å¼)
    const clean = str => str.replace(/[^\w\u4e00-\u9fa5]/g, '').toLowerCase();
    
    if (clean(input) === clean(target)) {
        fb.innerHTML = "ğŸ‰ ç­”å•±å’—ï¼"; fb.className = "spelling-feedback correct";
        fireConfetti();
        setTimeout(nextCard, 1500);
    } else {
        fb.innerHTML = "âŒ å†è©¦ä¸€æ¬¡"; fb.className = "spelling-feedback wrong";
    }
}

function showAnswer() {
    document.getElementById('spell-in').value = words[currentIndex];
    document.getElementById('feedback').innerText = "ğŸ‘€ ç­”æ¡ˆå·²é¡¯ç¤º";
}

// --- Navigation ---
function nextCard() {
    if (currentIndex < words.length - 1) { currentIndex++; render(); } 
    else { alert("ğŸ‰ å®Œæˆæ‰€æœ‰ç·´ç¿’ï¼"); exitApp(); }
}
function prevCard() { if (currentIndex > 0) { currentIndex--; render(); } }
function exitApp() { words = []; render(); }
function markKnown() { nextCard(); } // Placeholder for logic
function markUnknown() { nextCard(); } // Placeholder

// --- TTS Engine ---
function speak(text, callback) {
    if (synth.speaking) synth.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.rate = settings.rate;
    
    // Auto Detect Language for Voice Selection
    const isZh = /[\u4e00-\u9fa5]/.test(text);
    const voiceName = isZh ? settings.voiceZh : settings.voiceEn;
    const v = voices.find(v => v.name === voiceName);
    if (v) u.voice = v;
    
    u.onend = callback || null;
    synth.speak(u);
}

// --- OCR (Camera) ---
function triggerCamera() { document.getElementById('cam-input').click(); }
async function handleOCR(input) {
    if (!input.files || !input.files[0]) return;
    document.getElementById('ocr-loading').style.display = 'block';
    
    // Simulating OCR (Since we can't use real API key here)
    // In real usage, you'd fetch to Tesseract.js or Google Vision
    setTimeout(() => {
        const mockText = "Apple\nBanana\næ©™\nå£«å¤šå•¤æ¢¨";
        document.getElementById('input-words').value = mockText;
        document.getElementById('ocr-loading').style.display = 'none';
        alert("å·²è®€å–åœ–ç‰‡æ–‡å­— (æ¨¡æ“¬)");
    }, 1500);
}

// --- Confetti Effect (Mini) ---
function fireConfetti() {
    const c = document.getElementById('confetti');
    const ctx = c.getContext('2d');
    c.width = window.innerWidth; c.height = window.innerHeight;
    let p = [];
    for(let i=0;i<50;i++) p.push({x:c.width/2, y:c.height/2, dx:Math.random()*10-5, dy:Math.random()*10-5, c:`hsl(${Math.random()*360},100%,50%)`});
    function draw() {
        ctx.clearRect(0,0,c.width,c.height);
        p.forEach((k,i) => { k.x+=k.dx; k.y+=k.dy; k.dy+=0.2; ctx.fillStyle=k.c; ctx.fillRect(k.x,k.y,5,5); if(k.y>c.height) p.splice(i,1); });
        if(p.length) requestAnimationFrame(draw); else ctx.clearRect(0,0,c.width,c.height);
    }
    draw();
}
</script>
</body>
</html>
